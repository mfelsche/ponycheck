use "collections"
use "assert"
use "itertools"

type ValueAndShrink[T] is (T^, Iterator[T^])
type GenerateResult[T] is (T^ | ValueAndShrink)


class _Poperator[T] is Iterator[T^]
  """
  iterate over a `Seq` descructively by `pop`ing its elements

  once `has_next()` returns `false`, the `Seq` is empty.

  Nominee for the annual pony class-naming awards
  """

  let _seq: (Seq[T] | None)

  new create(seq: Seq[T]) =>
    _seq = seq

  new empty() =>
    """
    create an empty poperator
    that is not backed by any `Seq`
    for efficiency
    """
    _seq = None

  fun has_next(): Bool =>
    try
      (_seq as Seq[T]).size() > 0
    else
      false
    end

  fun next(): T^ ? =>
    (_seq as Seq[T]).pop()?


trait box GenObj[T]
  fun generate(rnd: Randomness): GenerateResult[T]

  fun shrink(t: T): ValueAndShrink[T] =>
    (consume t, _Poperator[T]())

  fun generate_value(rnd: Randomness): T^ =>
    """
    simply generate a value and ignore any possible
    shrink values
    """
    match generate(rnd)
    | let t: T => consume t
    | (let t: T, _) => consume t
    end

  fun generate_and_shrink(rnd: Randomness): ValueAndShrink[T] =>
    """
    generate a value and also return a shrink result
    even if the generator does not return any when calling `generate`.
    """
    match generate(rnd)
    | let t: T => shrink(consume t)
    | let vas: ValueAndShrink[T] => consume vas
    end

  fun iter(rnd: Randomness): Iterator[GenerateResult[T]]^ =>
    let gen: GenObj[T] = this

    object is Iterator[GenerateResult[T]]
      fun ref has_next(): Bool => true
      fun ref next(): GenerateResult[T] => gen.generate(rnd)
    end

  fun value_iter(rnd: Randomness): Iterator[T^]^ =>
    Iter[GenerateResult[T]](iter(rnd))
      .map[T^]({ (result: GenerateResult[T]): T^ =>
          match result
          | let value_only: T => consume value_only
          | (let v, _) => consume v
          end
        })

  fun value_and_shrink_iter(rnd: Randomness): Iterator[ValueAndShrink[T]]^ =>
    let gen: GenObj[T] = this

    Iter[GenerateResult[T]](iter(rnd))
      .map[ValueAndShrink[T]]({ (result: GenerateResult[T]): ValueAndShrink[T] =>
          match result
          | let value_only: T => gen.shrink(consume value_only)
          | let vas: ValueAndShrink[T] => consume vas
          end
        })



class box Generator[T] is GenObj[T]
  """
  A Generator is capable of generating random values of a certain type `T`
  given a source of `Randomness`
  and knows how to shrink or simplify values of that type.

  When testing a property against one or more given Generators
  those generators' `generate` methods are being called many times
  to generate sample values that are then used to validate the property.

  When a failing sample is found, the ponycheck engine is trying to find a
  smaller or more simple sample by `shrinking` it.
  If the generator did not provide any shrinked samples
  as a result of `generate`, its `shrink` method is called
  to obtain simpler results. Ponycheck obtains more shrunken samples until
  the property is not failing anymore.
  The last failing sample, which is considered the most simple one,
  is then reported to the user.
  """
  let _gen: GenObj[T]

  new create(gen: GenObj[T]) =>
    _gen = gen

  fun generate(rnd: Randomness): GenerateResult[T] =>
    """
    Let this generator generate a value
    given a source of `Randomness`.

    Also allow for returning a value and pre-generated shrink results
    as a `ValueAndShrink[T]` instance, a tuple of `(T^, Seq[T])`.
    This helps propagating shrink results through all kinds of Generator
    combinators like `filter`, `map` and `flatMap`.

    If implementing a custom `Generator` based on another one,
    a Generator Combinator, you should use shrunken values
    returned by `generate` to also return shrunken values based on them

    If generating an example value is costly, it might be more efficient
    to simply return the generated value and only shrink in big steps or do no
    shrinking at all.
    If generating values is lightweight, shrunken values should also be returned.
    """
    _gen.generate(rnd)

  fun shrink(t: T): ValueAndShrink[T] =>
    """
    Simplify the given value.

    As the returned value can also be `iso`, it needs to be consumed and returned

    It is preffered to already return a `ValueAndShrink` from `generate`.
    """
    _gen.shrink(consume t)

  fun generate_value(rnd: Randomness): T^ =>
    _gen.generate_value(rnd)

  fun generate_and_shrink(rnd: Randomness): ValueAndShrink[T] =>
    _gen.generate_and_shrink(rnd)

  fun filter(predicate: {(T): (T^, Bool)} box): Generator[T] =>
    """
    apply `predicate` to the values generated by this Generator
    and only values for which `predicate` returns `true`.

    Example:

    ```pony
    let even_i32s =
      Generators.i32()
        .filter(
          {(t: I32}: (I32^, Bool) => (t % 2) == 0 })
    ```
    """
    Generator[T](
      object is GenObj[T]
        fun generate(rnd: Randomness): GenerateResult[T] =>
          (let t: T, let shrunken: Iterator[T^]) = _gen.generate_and_shrink(rnd)
          (let t1, let matches) = predicate(consume t)
          if not matches then
            generate(rnd) // recurse, this might recurse infinitely
          else
            // filter the shrunken examples
            (consume t1, _filter_shrunken(shrunken))
          end

        fun shrink(t: T): ValueAndShrink[T] =>
          """
          shrink `t` using the generator this one filters upon
          and call the filter predicate on the shrunken values
          """
          (let s, let shrunken: Iterator[T^]) = _gen.shrink(consume t)
          (consume s, _filter_shrunken(shrunken))

        fun _filter_shrunken(shrunken: Iterator[T^]): Iterator[T^] =>
          Iter[T^](shrunken)
            .filter_map({
              (t: T): (T^| None) =>
                match predicate(consume t)
                | (let matching: T, true) => consume matching
                end
            })
      end)

  fun map[U](fn: {(T): U^} box)
    : Generator[U]
  =>
    """
    apply function `fn` to each value of this iterator
    and yield the results.

    Example:

    ```pony
    let single_code_point_string_gen =
      Generators.u32()
        .map[String]({(u: U32): String => String.from_utf32(u) })
    ```
    """
    Generator[U](
      object is GenObj[U]
        fun generate(rnd: Randomness): GenerateResult[U] =>
          (let generated: T, let shrunken: Iterator[T^]) =
            _gen.generate_and_shrink(rnd)

          (fn(consume generated), _map_shrunken(shrunken))

        fun shrink(u: U): ValueAndShrink[U] =>
          """
          We can only shrink if T is a subtype of U.

          This method should in general not be called on this generator
          as it is always returning shrinks with the call to `generate`
          and they should be used for executing the shrink, but in case
          a strange hierarchy of generators is used, which does not make use of
          the pre-generated shrink results, we keep this method here.
          """
          match u
          | let ut: T =>
            (let uts: T, let shrunken: Iterator[T^]) = _gen.shrink(consume ut)
            (fn(consume uts), _map_shrunken(shrunken))
          else
            (consume u, _Poperator.empty())
          end

        fun _map_shrunken(shrunken: Iterator[T^]): Iterator[U^] =>
          Iter[T^](shrunken)
            .map[U^]({(t: T): U^ => fn(consume t) })

      end)

  fun flat_map[U](fn: {(T): Generator[U]} box): Generator[U] =>
    """
    For each value of this generator create a generator that is then combined.
    """
    Generator[U](
      object is GenObj[U]
        fun generate(rnd: Randomness): GenerateResult[U] =>
          (let value: T, let shrunken: Iterator[T^]) =
            _gen.generate_and_shrink(rnd)
          let value_result = fn(consume value).generate(rnd)

          // apply fn to all shrink results and call the resulting generator
          let shrink_result =
            Iter[T^](shrunken)
              .map[U^]({
                (t: T): U^ =>
                  fn(consume t).generate_value(rnd) // ignore shrinks here
              })
          (consume value_result, shrink_result)
      end)

type WeightedGenerator[T] is (USize, Generator[T] box)
  """
  A generator with an associated weight, used in Generators.frequency.
  """

primitive Generators
  fun unit[T](t: T): Generator[box->T] =>
    """
    Generate a reference to the same value over and over again.

    This reference will be of type ``box->T`` and not just ``T``
    as this generator will need to keep a reference to the given value.
    """
    Generator[box->T](
      object is GenObj[box->T]
        let _t: T = consume t
        fun generate(rnd: Randomness): GenerateResult[box->T] => _t
      end)

  fun repeatedly[T](f: {(): T^} box): Generator[T] =>
    """
    Generate values by calling the lambda ``f`` repeatedly,
    once for every invocation of ``generate``.

    ``f`` needs to return an ephemeral type ``T^``, that means
    in most cases it needs to consume its returned value.
    Otherwise we would end up with
    an alias for ``T`` which is ``T!``.
    (e.g. ``String iso`` would be returned as ``String iso!``
    which is a ``String tag``).

    Example:

    ```pony
    Generators.repeatedly[Writer]({(): Writer^ =>
      let writer = Writer.>write("consume me, please")
      consume writer
    })
    ```
    """
    Generator[T](
      object is GenObj[T]
        fun generate(rnd: Randomness): GenerateResult[T] =>
          f()
      end)


  fun seq_of[T, S: Seq[T] ref](
    gen: Generator[T],
    min: USize = 0,
    max: USize = 100)
    : Generator[S]
  =>
    """
    Create a `Seq` from the values of the given Generator with an optional minimum and
    maximum size, defaults are 0 and 100 respectively.
    """
    Generator[S](
      object is GenObj[S]
        fun generate(rnd: Randomness): GenerateResult[S] =>
          let size = rnd.usize(min, max)

          (let result: S, let shrink_result: Seq[S]) =
            Iter[ValueAndShrink[T]](gen.value_and_shrink_iter(rnd))
              .take(size)
              .fold[(S, Seq[S])]((S.create(size), Array[S](size)), {
                // aggregate T values into Seq S
                // and T shrinks into separate Seqs of shrunken values
                ((s: S, final_shrinks: Seq[S]), (t: T, t_shrinks: Iterator[T^])) =>
                  s.push(consume t)
                  for (i, t_shrink) in Iter[T^](t_shrinks).enum() do
                    // upsert
                    let shrink_seq =
                      try
                        final_shrinks(i)?
                      else
                        let tmp = S.create(1)
                        final_shrinks.push(tmp)
                        tmp
                      end
                    shrink_seq.push(consume t_shrink)
                  end
                  (consume s, final_shrinks)
              })
          // TODO: add some more smaller samples, maybe empty collection
          (consume result, _Poperator(shrink_results))
      end)

  fun set_of[T: (Hashable #read & Equatable[T] #read)](
    gen: Generator[T],
    max: USize = 100)
    : Generator[Set[T]]
  =>
    """
    Create a generator for ``Set`` filled with values
    of the given generator ``gen``.
    The returned sets will have a size up to ``max``
    but tend to have fewer than ``max``
    depending on the source generator ``gen``.

    E.g. if the given generator is for ``U8`` values and ``max`` is set to 1024
    the set will only ever be of size 256 max.

    Also for efficiency purposes and to not loop forever
    this generator will only try to add at most ``max`` values to the set.
    If there are duplicates, the set won't grow.
    """
    Generator[Set[T]](
      object is GenObj[Set[T]]
        fun generate(rnd: Randomness): Set[T]^ =>
          let size = rnd.usize(0, max)

          (let result: Set[T], let shrink_results: Seq[Set[T]]) =
            Iter[ValueAndShrink[T]](gen.value_and_shrink_iter(rnd))
              .take(size)
              .fold[(Set[T], Seq[Set[T]])]((Set[T](size), Array[Set[T]](size)), {
                ((s: Set[T], final_shrinks: Seq[Set[T]]), (t: T, t_shrinks: Iterator[T^])) =>
                  s.set(consume t)
                  for (i, t_shrink) in Iter[T^](t_shrinks).enum() do
                    // upsert
                    let shrink_set =
                      try
                        final_shrinks(i)?
                      else
                        let tmp = Set[T].create(1)
                        final_shrinks.push(tmp)
                        tmp
                      end
                    shrink_set.set(consume t_shrink)
                  end
                  (consume s, final_shrinks)
            })
          // TODO: add some more smaller samples, maybe empty collection
          (consume result, _Poperator(shrink_results))
      end)

  fun set_is_of[T](
    gen: Generator[T],
    max: USize = 100)
    : Generator[SetIs[T]]
  =>
    """
    Create a generator for ``SetIs`` filled with values
    of the given generator ``gen``.
    The returned ``SetIs`` will have a size up to ``max``
    but tend to have fewer entries
    depending on the source generator ``gen``.

    E.g. if the given generator is for ``U8`` values and ``max`` is set to 1024
    the set will only ever be of size 256 max.

    Also for efficiency purposes and to not loop forever
    this generator will only try to add at most ``max`` values to the set.
    If there are duplicates, the set won't grow.
    """
    // TODO: how to remove code duplications
    Generator[SetIs[T]](
      object is GenObj[SetIs[T]]
        fun generate(rnd: Randomness): SetIs[T]^ =>
          let size = rnd.usize(0, max)

          (let result: SetIs[T], let shrink_result: Seq[SetIs[T]]) =
            Iter[ValueAndShrink[T]](gen.value_and_shrink_iter(rnd))
              .take(size)
              .fold[(SetIs[T], Seq[SetIs[T]])]((SetIs[T](size), Array[SetIs[T]](size)), {
                ((s: SetIs[T], final_shrinks: Seq[SetIs[T]]), (t: T, t_shrinks: Iterator[T^])) =>
                  s.set(consume t)
                  for (i, t_shrink) in Iter[T^](t_shrinks).enum() do
                    // upsert
                    let shrink_set =
                      try
                        final_shrinks(i)?
                      else
                        let tmp = SetIs[T].create(1)
                        final_shrinks.push(tmp)
                        tmp
                      end
                    shrink_set.set(consume t_shrink)
                  end
                  (consume s, final_shrinks)
              })
          // TODO: add some more smaller samples, maybe empty collection
          (consume result, _Poperator(shrink_result))
      end)

  fun map_of[K: (Hashable #read & Equatable[K] #read), V](
    gen: Generator[(K, V)],
    max: USize = 100)
    : Generator[Map[K, V]]
  =>
    """
    Create a generator for ``Map`` from a generator of key-value tuples.
    The generated maps will have a size up to ``max``
    but tend to have fewer entries depending on the source generator ``gen``.

    If the generator generates key-value pairs with
    duplicate keys (based on structural equality)
    the pair that is generated later will overwrite earlier entries in the map.
    """
    Generator[Map[K, V]](
      object is GenObj[Map[K, V]]
        fun generate(rnd: Randomness): GenerateResult[Map[K, V]] =>
          let size = rnd.usize(0, max)

          (let result: Map[K, V], let shrink_result: Seq[Map[K, V]]) =
            Iter[ValueAndShrink[(K^, V^)]](gen.value_and_shrink_iter(rnd))
              .take(size)
              .fold[ValueAndShrink[Map[K, V]]((Map[K, V].create(size), Array[Map[K, V]].create(size)), {
                ((m: Map[K, V], final_shrinks: Seq[Map[K, V]), (pair: (K, V), pair_shrinks: Iterator[(K^, V^)])) =>
                  (let k: K, let v: V) = consume pair
                  m.update(k, v)

                  for (i, pair_shrink) in Iter[T^](pair_shrinks).enum() do
                    (let pk, let pv) = consume pair_shrink
                    // upsert
                    let shrink_map =
                      try
                        final_shrinks(i)?
                      else
                        let tmp = Map[K, V].create(1)
                        final_shrinks.push(tmp)
                        tmp
                      end
                    shrink_map.update(consume pk, consume pv)
                  end
                  (consume m, final_shrinks)

              })
          // TODO: add some more smaller samples, maybe empty collection
          (consume result, _Poperator(shrink_result))

      end)

  fun map_is_of[K, V](
    gen: Generator[(K, V)],
    max: USize = 100)
    : Generator[MapIs[K, V]]
  =>
    """
    Create a generator for ``MapIs`` from a generator of key-value tuples.
    The generated maps will have a size up to ``max``
    but tend to have fewer entries depending on the source generator ``gen``.

    If the generator generates key-value pairs with
    duplicate keys (based on identity)
    the pair that is generated later will overwrite earlier entries in the map.
    """
    Generator[MapIs[K, V]](
      object is GenObj[MapIs[K, V]]
        fun generate(rnd: Randomness): GenerateResult[MapIs[K, V]] =>
          let size = rnd.usize(0, max)

          (let result: MapIs[K, V], let shrink_result: Seq[MapIs[K, V]]) =
            Iter[ValueAndShrink[(K^, V^)]](gen.value_and_shrink_iter(rnd))
              .take(size)
              .fold[ValueAndShrink[MapIs[K, V]]((MapIs[K, V].create(size), Array[MapIs[K, V]].create(size)), {
                ((m: MapIs[K, V], final_shrinks: Seq[MapIs[K, V]), (pair: (K, V), pair_shrinks: Iterator[(K^, V^)])) =>
                  (let k: K, let v: V) = consume pair
                  m.update(k, v)

                  for (i, pair_shrink) in Iter[T^](pair_shrinks).enum() do
                    (let pk, let pv) = consume pair_shrink
                    // upsert
                    let shrink_map =
                      try
                        final_shrinks(i)?
                      else
                        let tmp = MapIs[K, V].create(1)
                        final_shrinks.push(tmp)
                        tmp
                      end
                    shrink_map.update(consume pk, consume pv)
                  end
                  (consume m, final_shrinks)

              })
          // TODO: add some more smaller samples, maybe empty collection
          (consume result, _Poperator(shrink_result))
      end)


  fun one_of[T](xs: ReadSeq[T]): Generator[box->T] ? =>
    """
    Generate a random value from the given ReadSeq. An error will be thrown
    if the given ReadSeq is empty.

    Generators created with this method do not support shrinking.
    """
    Fact(xs.size() > 0, "cannot use one_of on empty ReadSeq")?

    Generator[box->T](
      let err: box->T = xs(0)?
      object is GenObj[box->T]
        fun generate(rnd: Randomness): GenerateResult[box->T] =>
          let idx = rnd.usize(0, xs.size() - 1)
          try
            xs(idx)?
          else
            err // will never occur
          end
      end)

  fun frequency[T](
    weighted_generators: ReadSeq[WeightedGenerator[T]])
    : Generator[T] ?
  =>
    """
    chose a value of one of the given Generators,
    while controlling the distribution with the associated weights.

    The weights are of type ``USize`` and control how likely a value is chosen.
    The likelihood of a value ``v`` to be chosen
    is ``weight_v`` / ``weights_sum``.
    If all ``weighted_generators`` have equal size the distribution
    will be uniform.

    Example of a generator to output odd ``U8`` values
    twice as likely as even ones:

    ```pony
    Generators.frequency[U8]([
      (1, Generators.u8().filter({(u: U8): (U8^, Bool) => (u, (u % 2) == 0 }))
      (2, Generators.u8().filter({(u: U8): (U8^, Bool) => (u, (u % 2) != 0 }))
    ])
    ```
    """
    Fact(weighted_generators.size() > 0, "cannot use frequency on empty ReadSeq[WeightedGenerator]")

    // nasty hack to avoid handling the theoretical error case where we have
    // no generator and thus would have to change the type signature
    let err = weighted_generators(0)?._2

    Generator[T](
      object is GenObj[T]
        fun generate(rnd: Randomness): GenerateResult[T] =>
          let weight_sum: USize =
            Iter[WeightedGenerator[T]](weighted_generators.values())
              .fold[USize](
                0,
                {(acc: USize, weighted_gen: WeightedGenerator[T]): USize =>
                  weighted_gen._1 + acc
                })
          let desired_sum = rnd.usize(0, weight_sum)
          var running_sum: USize = 0
          var chosen: (Generator[T] | None) = None
          for weighted_gen in weighted_generators.values() do
            let new_sum = running_sum + weighted_gen._1
            if (running_sum < desired_sum) and (desired_sum <= new_sum) then
              // we just crossed or reached the desired sum
              chosen = weighted_gen._2
              break
            else
              // update running sum
              running_sum = new_sum
            end
          end
          match chosen
          | let x: Generator[T] box => x.generate(rnd)
          | None => err.generate(rnd)
          end
      end)

  fun zip2[T1, T2](
    gen1: Generator[T1],
    gen2: Generator[T2])
    : Generator[(T1, T2)]
  =>
    """
    zip two generators into a generator of a 2-tuple
    containing the values generated by both generators.
    """
    Generator[(T1, T2)](
      object is GenObj[(T1, T2)]
        fun generate(rnd: Randomness): GenerateResult[(T1, T2)] =>
          (let v1: T1, let shrinks1: Iterator[T1^]) =
            gen1.generate_and_shrink(rnd)
          (let v2: T2, let shrinks2: Iterator[T2^]) =
            gen2.generate_and_shrink(rnd)
          ((consume v1, consume v2), Iter[T1^](shrinks1).zip[T2^](shrinks2))

        fun shrink(t: (T1, T2)): ValueAndShrink[(T1, T2)] =>
          (let t1, let t2) = consume t
          (let t11, let t1_shrunken: Iterator[T1^]) = gen1.shrink(consume t1)
          (let t21, let t2_shrunken: Iterator[T2^]) = gen2.shrink(consume t2)

          let shrunken = Iter[T1^](t1_shrunken).zip[T2^](t2_shrunken)
          ((consume t11, consume t21), shrunken)
      end)

  fun zip3[T1, T2, T3](
    gen1: Generator[T1],
    gen2: Generator[T2],
    gen3: Generator[T3])
    : Generator[(T1, T2, T3)]
  =>
    """
    zip three generators into a generator of a 3-tuple
    containing the values generated by those three generators.
    """
    Generator[(T1, T2, T3)](
      object is GenObj[(T1, T2, T3)]
        fun generate(rnd: Randomness): GenerateResult[(T1, T2, T3)] =>
          (let v1: T1, let shrinks1: Iterator[T1^]) =
            gen1.generate_and_shrink(rnd)
          (let v2: T2, let shrinks2: Iterator[T2^]) =
            gen2.generate_and_shrink(rnd)
          (let v3: T3, let shrinks3: Iterator[T3^]) =
            gen3.generate_and_shrink(rnd)
          ((consume v1, consume v2, consume v3),
              Iter[T1^](shrinks1).zip2[T2^, T3^](shrinks2, shrinks3))

        fun shrink(t: (T1, T2, T3)): ValueAndShrink[(T1, T2, T3)] =>
          (let t1, let t2, let t3) = consume t
          (let t11, let t1_shrunken: Iterator[T1^]) = gen1.shrink(consume t1)
          (let t21, let t2_shrunken: Iterator[T2^]) = gen2.shrink(consume t2)
          (let t31, let t3_shrunken: Iterator[T3^]) = gen3.shrink(consume t3)

          let shrunken = Iter[T1^](t1_shrunken).zip2[T2^, T3^](t2_shrunken, t3_shrunken)
          ((consume t11, consume t21, consume t31), shrunken)
        end)

  fun zip4[T1, T2, T3, T4](
    gen1: Generator[T1],
    gen2: Generator[T2],
    gen3: Generator[T3],
    gen4: Generator[T4])
    : Generator[(T1, T2, T3, T4)]
  =>
    """
    zip four generators into a generator of a 4-tuple
    containing the values generated by those four generators.
    """
    Generator[(T1, T2, T3, T4)](
      object is GenObj[(T1, T2, T3, T4)]
        fun generate(rnd: Randomness): GenerateResult[(T1, T2, T3, T4)] =>
          (let v1: T1, let shrinks1: Iterator[T1^]) =
            gen1.generate_and_shrink(rnd)
          (let v2: T2, let shrinks2: Iterator[T2^]) =
            gen2.generate_and_shrink(rnd)
          (let v3: T3, let shrinks3: Iterator[T3^]) =
            gen3.generate_and_shrink(rnd)
          (let v4: T4, let shrinks4: Iterator[T4^]) =
            gen4.generate_and_shrink(rnd)
          ((consume v1, consume v2, consume v3, consume v4),
              Iter[T1^](shrinks1).zip3[T2^, T3^, T4^](shrinks2, shrinks3, shrinks4))

        fun shrink(t: (T1, T2, T3, T4)): ValueAndShrink[(T1, T2, T3, T4)] =>
          (let t1, let t2, let t3, let t4) = consume t
          (let t11, let t1_shrunken: Seq[T1]) = gen1.shrink(consume t1)
          (let t21, let t2_shrunken: Seq[T2]) = gen2.shrink(consume t2)
          (let t31, let t3_shrunken: Seq[T3]) = gen3.shrink(consume t3)
          (let t41, let t4_shrunken: Seq[T4]) = gen4.shrink(consume t4)

          let shrunken = Iter[T1^](t1_shrunken)
            .zip3[T2^, T3^, T4^](t2_shrunken, t3_shrunken, t4_shrunken)
          ((consume t11, consume t21, consume t31, consume t41), shrunken)
        end)

  fun bool(): Generator[Bool] =>
    """
    create a generator of bool values.
    """
    Generator[Bool](
      object is GenObj[Bool]
        fun generate(rnd: Randomness): Bool =>
          rnd.bool()
        end)

  fun _int_shrink[T: (Int & Integer[T] val)](t: T^, min: T): (T^, Seq[T]) =>
    let shrunken = Array[T](3)
    if t > min then
      shrunken.push(min)
    end
    if t > (min+1) then
      shrunken.push(min+1)
    end
    if t > (min+2) then
      shrunken.push(t-1)
    end
    (consume t, shrunken)

  fun u8(
    min: U8 = U8.min_value(),
    max: U8 = U8.max_value())
    : Generator[U8]
  =>
    """
    create a generator for U8 values
    """
    let that = this
    Generator[U8](
      object is GenObj[U8]
        fun generate(rnd: Randomness): U8^ =>
          rnd.u8(min, max)

        fun shrink(u: U8): (U8^, Seq[U8]) =>
          that._int_shrink[U8](consume u, min)
        end)

  fun u16(
    min: U16 = U16.min_value(),
    max: U16 = U16.max_value())
    : Generator[U16]
  =>
    """
    create a generator for U16 values
    """
    let that = this
    Generator[U16](
      object is GenObj[U16]
        fun generate(rnd: Randomness): U16^ =>
          rnd.u16(min  max)

        fun shrink(u: U16): (U16^, Seq[U16]) =>
          that._int_shrink[U16](consume u, min)
      end)

  fun u32(
    min: U32 = U32.min_value(),
    max: U32 = U32.max_value())
    : Generator[U32]
  =>
    """
    create a generator for U32 values
    """
    let that = this
    Generator[U32](
      object is GenObj[U32]
        fun generate(rnd: Randomness): U32^ =>
          rnd.u32(min, max)

        fun shrink(u: U32): (U32^, Seq[U32]) =>
          that._int_shrink[U32](consume u, min)
      end)

  fun u64(
    min: U64 = U64.min_value(),
    max: U64 = U64.max_value())
    : Generator[U64]
  =>
    """
    create a generator for U64 values
    """
    let that = this
    Generator[U64](
      object is GenObj[U64]
        fun generate(rnd: Randomness): U64^ =>
          rnd.u64(min, max)

        fun shrink(u: U64): (U64^, Seq[U64]) =>
          that._int_shrink[U64](consume u, min)
      end)

  fun u128(
    min: U128 = U128.min_value(),
    max: U128 = U128.max_value())
    : Generator[U128]
  =>
    """
    create a generator for U128 values
    """
    let that = this
    Generator[U128](
      object is GenObj[U128]
        fun generate(rnd: Randomness): U128^ =>
          rnd.u128(min, max)

        fun shrink(u: U128): (U128^, Seq[U128]) =>
          that._int_shrink[U128](consume u, min)
      end)

  fun usize(
    min: USize = USize.min_value(),
    max: USize = USize.max_value())
    : Generator[USize]
  =>
    """
    create a generator for USize values
    """
    let that = this
    Generator[USize](
      object is GenObj[USize]
        fun generate(rnd: Randomness): USize^ =>
          rnd.usize(min, max)

        fun shrink(u: USize): (USize^, Seq[USize]) =>
          that._int_shrink[USize](consume u, min)
      end)

  fun ulong(
    min: ULong = ULong.min_value(),
    max: ULong = ULong.max_value())
    : Generator[ULong]
  =>
    """
    create a generator for ULong values
    """
    let that = this
    Generator[ULong](
      object is GenObj[ULong]
        fun generate(rnd: Randomness): ULong^ =>
          rnd.ulong(min, max)

        fun shrink(u: ULong): (ULong^, Seq[ULong]) =>
          that._int_shrink[ULong](consume u, min)
      end)

  fun i8(
    min: I8 = I8.min_value(),
    max: I8 = I8.max_value())
    : Generator[I8]
  =>
    """
    create a generator for I8 values
    """
    let that = this
    Generator[I8](
      object is GenObj[I8]
        fun generate(rnd: Randomness): I8^ =>
          rnd.i8(min, max)

        fun shrink(i: I8): (I8^, Seq[I8]) =>
          that._int_shrink[I8](consume i, min)
      end)

  fun i16(
    min: I16 = I16.min_value(),
    max: I16 = I16.max_value())
    : Generator[I16]
  =>
    """
    create a generator for I16 values
    """
    let that = this
    Generator[I16](
      object is GenObj[I16]
        fun generate(rnd: Randomness): I16^ =>
          rnd.i16(min, max)

        fun shrink(i: I16): (I16^, Seq[I16]) =>
          that._int_shrink[I16](consume i, min)
      end)

  fun i32(
    min: I32 = I32.min_value(),
    max: I32 = I32.max_value())
    : Generator[I32]
  =>
    """
    create a generator for I32 values
    """
    let that = this
    Generator[I32](
      object is GenObj[I32]
        fun generate(rnd: Randomness): I32^ =>
          rnd.i32(min, max)

        fun shrink(i: I32): (I32^, Seq[I32]) =>
          that._int_shrink[I32](consume i, min)
      end)

  fun i64(
    min: I64 = I64.min_value(),
    max: I64 = I64.max_value())
    : Generator[I64]
  =>
    """
    create a generator for I64 values
    """
    let that = this
    Generator[I64](
      object is GenObj[I64]
        fun generate(rnd: Randomness): I64^ =>
          rnd.i64(min, max)

        fun shrink(i: I64): (I64^, Seq[I64]) =>
          that._int_shrink[I64](consume i, min)
      end)

  fun i128(
    min: I128 = I128.min_value(),
    max: I128 = I128.max_value())
    : Generator[I128]
  =>
    """
    create a generator for I128 values
    """
    let that = this
    Generator[I128](
      object is GenObj[I128]
        fun generate(rnd: Randomness): I128^ =>
          rnd.i128(min, max)

        fun shrink(i: I128): (I128^, Seq[I128]) =>
          that._int_shrink[I128](consume i, min)
      end)

  fun ilong(
    min: ILong = ILong.min_value(),
    max: ILong = ILong.max_value())
    : Generator[ILong]
    =>
    """
    create a generator for ILong values
    """
    let that = this
    Generator[ILong](
      object is GenObj[ILong]
        fun generate(rnd: Randomness): ILong^ =>
          rnd.ilong(min, max)

        fun shrink(i: ILong): (ILong^, Seq[ILong]) =>
          that._int_shrink[ILong](consume i, min)
      end)

  fun isize(
    min: ISize = ISize.min_value(),
    max: ISize = ISize.max_value())
    : Generator[ISize]
  =>
    """
    create a generator for ISize values
    """
    let that = this
    Generator[ISize](
      object is GenObj[ISize]
        fun generate(rnd: Randomness): ISize^ =>
          rnd.isize(min, max)

        fun shrink(i: ISize): (ISize^, Seq[ISize]) =>
          that._int_shrink[ISize](consume i, min)
      end)


  fun byte_string(
    gen: Generator[U8],
    min: USize = 0,
    max: USize = 100)
    : Generator[String]
  =>
    """
    create a generator for strings
    generated from the bytes returned by the generator ``gen``
    with a minimum length of ``min`` (default: 0)
    and a maximum length of ``max`` (default: 100).
    """
    Generator[String](
      object is GenObj[String]
        fun generate(rnd: Randomness): GenerateResult[String] =>
          let size = rnd.usize(min, max)
          let gen_iter = Iter[U8^](gen.iter(rnd))
            .take(size)
          let arr: Array[U8] iso = recover Array[U8](size) end
          for b in gen_iter do
            arr.push(b)
          end
          String.from_iso_array(consume arr)

        fun shrink(s: String): ValueAndShrink[String] =>
          """
          shrink string until ``min`` length.
          try to add empty string and single char string
          if ``min`` allows this.
          """
          let shrunken = Array[String](3)
          let size = s.size()
          if size > min then
            if min == 0 then
              shrunken.push("")
            end
            if (min <= 1) and (size > 1) then
              shrunken.push(recover val s.substring(0, 1) end)
            end
            if (size-1) >= min then
              shrunken.push(recover val s.substring(0, -1) end)
            end
          end
          (consume s, shrunken)
      end)

  fun ascii(
    min: USize = 0,
    max: USize = 100,
    range: ASCIIRange = ASCIIAll)
    : Generator[String]
  =>
    """
    create a generator for strings withing the given ``range``
    with a minimum length of ``min`` (default: 0)
    and a maximum length of ``max`` (default: 100).
    """
    let range_bytes = range()
    let fallback = U8(0)
    let range_bytes_gen = usize(0, range_bytes.size()-1)
      .map[U8]({(size: USize): U8^ =>
        try
          range_bytes(size)?
        else
          // should never happen
          fallback
        end })
    byte_string(range_bytes_gen, min, max)

  fun ascii_printable(
    min: USize = 0,
    max: USize = 100)
    : Generator[String]
  =>
    """
    create a generator for strings of printable ascii characters
    with a minimum length of ``min`` (default: 0)
    and a maximum length of ``max`` (default: 100).
    """
    ascii(min, max, ASCIIPrintable)

  fun ascii_numeric(
    min: USize = 0,
    max: USize = 100)
    : Generator[String]
  =>
    """
    create a generator for strings of numeric ascii characters
    with a minimum length of ``min`` (default: 0)
    and a maximum length of ``max`` (default: 100).
    """
    ascii(min, max, ASCIIDigits)

  fun ascii_letters(
    min: USize = 0,
    max: USize = 100)
    : Generator[String]
  =>
    """
    create a generator for strings of ascii letters
    with a minimum length of ``min`` (default: 0)
    and a maximum length of ``max`` (default: 100).
    """
    ascii(min, max, ASCIILetters)

  fun utf32_codepoint_string(
    gen: Generator[U32],
    min: USize = 0,
    max: USize = 100)
    : Generator[String]
  =>
    """
    create a generator for strings
    from a generator of unicode codepoints
    with a minimum length of ``min`` codepoints (default: 0)
    and a maximum length of ``max`` codepoints (default: 100).

    Note that the byte length of the generated string can be up to 4 times
    the size in code points.
    """
    Generator[String](
      object is GenObj[String]
        fun generate(rnd: Randomness): String^ =>
          let size = rnd.usize(min, max)
          let gen_iter = Iter[U32^](gen.iter(rnd))
            .filter({(cp: U32): Bool =>
              // excluding surrogate pairs
              (cp <= 0xD7FF) or (cp >= 0xE000) })
            .take(size)
          let s: String iso = recover String(size) end
          for code_point in gen_iter do
            s.push_utf32(code_point)
          end
          s

        fun shrink(s: String): (String^, Seq[String]) =>
          """
          strip off codepoints from the end, not just bytes, so we
          maintain a valid utf8 string

          only shrink until given ``min`` is hit
          """
          let shrunken = Array[String](3)
          let cps: USize = s.codepoints()
          if cps > min then
            if min == 0 then
              shrunken.push("")
            end
            if min <= 1 then
              try
                // add single code point string
                shrunken.push(
                  recover val String.from_utf32(s.runes().next()?) end
                )
              end
            end
            if (cps-1) >= min then
              // add capped by one codepoint
              let capped: String val = recover val
                Iter[U32](s.runes())
                  .take(cps-1)
                  .fold[String ref](
                    String.create(s.size()),
                    {(acc: String ref, cp: U32): String ref => acc.>push_utf32(cp) })
                end
              shrunken.push(capped)
            end
          end
          (consume s, shrunken)
      end)


  fun unicode(
    min: USize = 0,
    max: USize = 100)
    : Generator[String]
  =>
    """
    create a generator for unicode strings
    with a minimum length of ``min`` codepoints (default: 0)
    and a maximum length of ``max`` codepoints (default: 100).

    Note that the byte length of the generated string can be up to 4 times
    the size in code points.
    """
    let range_1 = u32(0x0, 0xD7FF)
    let range_1_size: USize = 0xD7FF
    // excluding surrogate pairs
    // this might be duplicate work but increases efficiency
    let range_2 = u32(0xE000, 0x10FFFF)
    let range_2_size = U32(0x10FFFF - 0xE000).usize()

    let code_point_gen =
      try
        frequency[U32]([
          (range_1_size, range_1)
          (range_2_size, range_2)
        ])?
      else
        // should never happen
        unit[U32](U32(0))
      end
    utf32_codepoint_string(code_point_gen, min, max)

  fun unicode_bmp(
    min: USize = 0,
    max: USize = 100)
    : Generator[String]
  =>
    """
    create a generator for unicode strings
    from the basic multilingual plane only
    with a minimum length of ``min`` codepoints (default: 0)
    and a maximum length of ``max`` codepoints (default: 100).

    Note that the byte length of the generated string can be up to 4 times
    the size in code points.
    """
    let range_1 = u32(0x0, 0xD7FF)
    let range_1_size: USize = 0xD7FF
    // excluding surrogate pairs
    // this might be duplicate work but increases efficiency
    let range_2 = u32(0xE000, 0xFFFF)
    let range_2_size = U32(0xFFFF - 0xE000).usize()

    let code_point_gen =
      try
        frequency[U32]([
          (range_1_size, range_1)
          (range_2_size, range_2)
        ])?
      else
        // should never happen
        unit[U32](U32(0))
      end
    utf32_codepoint_string(code_point_gen, min, max)

